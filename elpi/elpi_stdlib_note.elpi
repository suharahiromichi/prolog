/**
ELPI の組込述語 (stdlib編)
=====================

@suharahiromichi

2022/12/02
*/

/**
Embeddable Lambda Prolog Interpreter (ELPI) は、
定理証明支援系 Coq の拡張に使えるλProlog (lProlog) の処理系ですが、
ドキュメントが少なく、とくに組込述語（一般的なプログラミング言語の組込関数にあたる）
の解説がないため、作成してみました。

ここでは、ELPIのソースコード [1]

``src/builtin_stdlib.elpi``


の ``namespace std`` で定義された組込述語を
できるだけ例を交えて説明します。

λPrologやELPI自体の説明は [2] とそこに書いた参考文献を参考にしてください。

この組込述語は、ドキュメントではstdlibと呼ばれますが、
呼び出し時には、``std.``を付けます。stdlib ではないので、注意してください。
なお、これ以外に特別な宣言は要りません。

このファイルは以下にあります。


https://github.com/suharahiromichi/prolog/blob/master/elpi/elpi_stdlib_note.elpi


このファイルの例の使い方は、コマンドラインから、elpiコマンドの引数として呼び出してください。
対話モードで ``goal> ``プロンプトの後に``test 10.``や``test11.``
などと入力してください。Enterの前に``.``が要ります。
一般的なPrologと異なり、一回毎にコマンドプロンプトに戻りますので、elpi
コマンドから実行してください。

```
% elpi elpi_stdlib_note.elpi
goal> test10.<Enter>

% elpi elpi_stdlib_note.elpi
goal> test11.<Enter>
```
*/

/**
# stdlib の使い方

述語名の前に``std.``を付けて使います。
λProlog の標準的な型として、命題を表す``prop``の他、以下の型が使われいます。

- ``int``
- ``float``
- ``string``
- ``list A``
- ``diagnostic``

前三つは一般的な定義で、float は``1.0``と小数点をつけて、
stringはダブルクォーテーションで囲んで表現します。

list は、次のように定義されています。ここで``X``は任意の型を示す型変数です。
``::``はcons、``[]``はnilを表します。通常のProlog (以下、ISO Prologと呼びます)
の``[ a | b ]``という表記も使えます。

```
kind list type -> type.
type (::) X -> list X -> list X.
type ([]) list X.
```


diagnostic は、次のように定義されています。

```
kind diagnostic type.
type ok diagnostic.              % Success
type error string -> diagnostic. % Failure
```
*/

/**
# 規約

最初に ``builtin_stdlib.elpi`` の冒頭のコメントを訳しておきます。

- すべての述語は、いくつかの入力引数を使用してモードを宣言します...

- 名前が R で終わる述語はリレーションです（あらゆる方向に機能します。
  つまり、すべての引数が出力モードになります）。

- 名前が``!``で終わる述語 カットを含み、最初の結果のみを生成します。

- このライブラリによって与えられたすべてのエラーは、``fatal-error[-w-data]``
  を呼び出すことになり、別の方法で処理するためにそれをオーバーライドします。

- このライブラリによるすべてのデバッグ出力は最終的に debug-print を呼
  び出し、異なる方法で処理するためにオーバーライドします。
*/

/**
# stdlib の説明
*/

/**
## pred fatal-error i:string.
*/
/**
## pred fatal-error-w-data i:string, i:A.
*/
/**
## pred debug-print i:string, i:A.
*/
/**
## pred ignore-failure! i:prop.


命題Pが失敗しても成功しても、``ignore-failure! P``は成功する。
いずれの場合も、バックトラックして戻ってきた場合は、``P``によらず失敗する。
*/

pred test4.
test4 :-
      std.ignore-failure! true,
      print 1,
      std.ignore-failure! fail,
      print 2.

/**
## pred assert! i:prop, i:string.


``assert! C M``で、Cが失敗したら、メッセージMを出力する。
*/

pred test5.
test5 :-
      std.assert! fail "Fail!".

/**
## pred assert-ok! i:(diagnostic -> prop), i:string.

``assert!``と似ているが、対象の命題が診断結果として、
``ok``または``error S``を返すことを前提とする。
*/
pred sample6 o:diagnostic.
sample6 (error "an error").
pred test6.
test6 :-
      std.assert-ok! sample6 "diag-result".

/**
## pred spy i:prop.
*/

/**
## pred spy! i:prop.
*/

/**
## pred unsafe-cast o:A, o:B.

ELPIの型チェックを回避する。
次の例は、float (1.0) を int であるべき箇所 sample8 に代入している。
*/
pred test8.
pred sample8 i:int.
sample8 X :-
        print X.
test8 :-
      std.unsafe-cast 1.0 X,
      sample8 X.

/**
## pred length i:list A, o:int.

最後の引数が出力となる。最初の引数が変数（未束縛）ならエラーになる。
*/
pred test9.
test9 :-
      std.length [1, 2, 3] N,
      std.debug-print "length is" N.

/**
## pred rev i:list A, o:list A.

リストを反転します。最後の引数が出力となる。
じつは、std.revの定義は良いものではなく、``std.rev X [3,2,1]``は無限ループになります。
しかし、引数のi/oを守る限り問題はありません。
*/
pred test10.
test10 :-
       std.rev [1, 2, 3] X,
       std.debug-print "rev is" X.

/**
## pred last i:list A, o:A.

最後の引数が出力となる。
*/
pred test11.
test11 :-
       std.last [1, 2, 3] X,
       std.debug-print "last is" X.

/**
## pred append i:list A, i:list A, o:list A.

最後の引数が出力となる。
*/
pred test12.
test12 :-
       std.append [1, 2, 3] [4, 5, 6] X,
       std.debug-print "append is" X.

/**
## pred appendR o:list A, o:list A, o:list A.

規約の2番目の例。非決定的な append である。
以降では、述語が成功する条件のみならず、
バックトラックしても成功するか、
さらに、何回成功するか、も考えてみてください。
*/
pred test13.
test13 :-
       std.appendR X Y [1, 2, 3, 4, 5, 6],
       print "append is" X "and" Y,
       fail.

/**
## pred take i:int, i:list A, o:list A.

最後の引数が出力となる。先頭からN個とりだす。
lengthより大きければ、fatal errorとなる。
*/
pred test14.
test14 :-
       std.take 2 [1, 2, 3] X,
       print "take 2 is" X.

/**
## pred take-last i:int, i:list A, o:list A.

最後の引数が出力となる。末尾からN個とりだす。
lengthより大きければ、fatal errorとなる。
*/
pred test15.
test15 :-
       std.take-last 2 [1, 2, 3] X,
       print "take-last 2 is" X.

/**
## pred drop i:int, i:list A, o:list A.

最後の引数が出力となる。先頭からN個捨てる。
lengthより大きければ、fatal errorとなる。
*/
pred test16.
test16 :-
       std.drop 2 [1, 2, 3] X,
       print "drop 2 is" X.

/**
## pred drop-last i:int, i:list A, o:list A.

最後の引数が出力となる。末尾からN個捨てる。
lengthより大きければ、fatal errorとなる。
*/
pred test17.
test17 :-
       std.drop-last 2 [1, 2, 3] X,
       print "drop-last 2 is" X.

/**
## pred split-at i:int, i:list A, o:list A, o:list A.

最後の引数が出力となる。最初の要素の前を0として、N番目のところで分割する。
*/
pred test18.
test18 :-
       std.split-at 2 [1, 2, 3, 4] X Y,
       print "split at" X Y.
       
/**
## pred fold i:list B, i:A, i:(B -> A -> A -> prop), o:A.

fold_right。
普段はそのような使い方はしないが、Fが複数解あるときは、バックトラックで使われる。
*/
pred test19.
pred plus i:int i:int o:int.
plus A B C :-
     C is A + B.
test19 :-
       std.fold [1, 2, 3] 0 plus X,
       print "fold plus is" X.

/**
## pred fold2 i:list C, i:list B, i:A, i:(C -> B -> A -> A -> prop), o:A.
*/
pred test20.
pred plus2 i:int i:int i:int o:int.
plus2 A B C D :-
     D is A + B + C.
test20 :-
       std.fold2 [1, 2, 3] [4, 5, 6] 0 plus2 X,
       print "fold2 plus2 is" X.

/**
## pred map i:list A, i:(A -> B -> prop), o:list B.

普段はそのような使い方はしないが、
Fが複数解あるときは、バックトラックで使われる。
Fがfailすると全体がFailする。
*/
pred test21.
pred minus1 i:int o:int.
minus1 X Y :-
      Y is ~ X.
minus1 X Y :-
      Y is X + 1.
test21 :-
       std.map [1, 2, 3] minus1 X,
       print "map minus1 is" X.

/**
## pred map-i i:list A, i:(int -> A -> B -> prop), o:list B.
*/
/**
## pred map-filter i:list A, i:(A -> B -> prop), o:list B.

Fがfailした場合は、結果から抜かれる。
*/
pred test23.
pred even2 i:int o:int.
even2 N M :-
     M is (N div 2) * 2,
     N = M.
test23 :-
       std.map-filter [1, 2, 3, 4] even2 X,
       print "map even is" X.

/**
## pred map2 i:list A, i:list B, i:(A -> B -> C -> prop), o:list C.
*/
/**
## pred map2-filter i:list A, i:list B, i:(A -> B -> C -> prop), o:list C.
*/
/**
## pred map-ok i:list A, i:(A -> B -> diagnostic -> prop), o:list A, o:diagnostic.
*/
/**
## pred fold-map i:list A, i:B, i:(A -> B -> C -> B -> prop), o:list C, o:B.
*/
/**
## pred omap i:option A, i:(A -> B -> prop), o:option B.
*/
pred test28.
pred minus i:int o:int.
minus N M :-
      M is ~ N.
test28 :-
       std.omap (some 1) minus X,
       print "omap is" X.

/**
## pred nth i:int, i:list A, o:A.

先頭を0として、N番目の要素を取り出す。ISO Prologの ``nth``。
*/
pred test29.
test29 :-
       std.nth 0 [1, 2, 3] X,
       print "nth is" X.

/**
## pred lookup i:list (pair A B), i:A, o:B.

連想配列。バックトラックで複数解が得られる。
*/
pred test30.
test30 :-
       std.lookup [pr 1 11, pr 2 12, pr 1 13] 1 X,
       print "lookup 1 is" X,
       fail.

/**
## pred lookup! i:list (pair A B), i:A, o:B.

連想配列。唯一解のみ。
*/
pred test31.
test31 :-
       std.lookup! [pr 1 11, pr 2 12, pr 1 13] 1 X,
       print "lookup! 1 is" X,
       fail.
/**
## pred mem! i:list A, o:A.

``∈`` 決定的に動作する。
*/
pred test32.
test32 :-
       std.mem! [1, 2, 1] 1,
       print "succ".

/**
## pred mem i:list A, o:A.

``∈`` 非決定的…バックトラックで戻ってきても、要素の個数だけ成功する。
*/
pred test33.
test33 :-
       std.mem [1, 2, 1] 1,
       print "succ",
       fail.

/**
## pred exists i:list A, i:(A -> prop).

リストに``P``を満たす要素 x があれば成功する。
要素が複数あれば、バックトラックしてもその回数だけ成功する。
``P x``が複数回成功するなら、その分も成功する。
*/
pred test34.
pred one i:int.
one 1.
test34 :-
       std.exists [1, 2, 1] one,
       print "ok",
       fail.

/**
## pred exists2 i:list A, i:list B, i:(A -> B -> prop).
*/
/**
## pred forall i:list A, i:(A -> prop).
*/
/**
## pred forall-ok i:list A, i:(A -> diagnostic -> prop), o:diagnostic.
*/
/**
## pred forall2 i:list A, i:list B, i:(A -> B -> prop).
*/
/**
## pred filter i:list A, i:(A -> prop), o:list A.
*/
/**
## pred zip i:list A, i:list B, o:list (pair A B).
*/
/**
## pred unzip i:list (pair A B), o:list A, o:list B.
*/
/**
## pred flatten i:list (list A), o:list A.
*/
/**
## pred null i:list A.

リストか``nil``なら成功します。
*/
pred test43.
test43 :-
       not (std.null [_]),
       std.null [],
       std.null nil,
       print "[] is null".

/**
## pred iota i:int, o:list int.

``0``から``N-1``までのリストを返す。
*/
pred test44.
test44 :-
       std.iota 3 X,
       print "iota is" X.

/**
## pred intersperse i:A, i:list A, o:list A.
*/
/**
## pred flip i:(A -> B -> prop), i:B, i:A.
*/
/**
## pred time i:prop, o:float.
*/
/**
## pred do! i:list prop.
*/
/**
## pred do-ok! o:diagnostic, i:list (diagnostic -> prop).
*/
/**
## pred lift-ok i:prop, i:string, o:diagnostic.
*/
/**
## pred spy-do! i:list prop.
*/
/**
## pred while-ok-do! i:diagnostic, i:list (diagnostic -> prop), o:diagnostic.
*/
/**
## pred any->string i:A, o:string.
*/
/**
## pred max i:A, i:A, o:A.
*/
/**
## pred findall i:prop, o:list prop.

バックトラックで得られる複数解をリストとして返します。
第1引数のprop全体を返すのが、ISO Prologと異なります。
この過程で、第1引数のpropが実行されるため、printなどのその副作用も実行されます。
*/
pred test55.
pred sample55 o:int.
sample55 1.
sample55 2 :- print "this is 2".
sample55 3.
test55 :-
       std.findall (sample55 X) L,
       print "findall is " L.

/**
# namespace についての説明

namespace はネストできますが、
その外からはその全てを指定する必要があります。
*/

namespace space1 {
namespace space2 {
pred test99.
test99 :- std.rev [97, 98, 99] X, print X.
}
}
pred test99_1.
test99_1 :- space1.space2.test99.

/**
# 参考文献

[1] ELPIソースコード

https://github.com/LPCIC/elpi/tree/master/


[2] λProlog (Lambda Prolog) の紹介

https://qiita.com/suharahiromichi/items/a046859da0c0883e7304
*/

/* END */
