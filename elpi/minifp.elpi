%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% miniFp
%
% http://users.cecs.anu.edu.au/~tiu/teaching/lprolog/index.html
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% sig.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

kind tm type.	% syntactic category for miniFP terms
kind ty type.	% syntactic category for miniFP types

type bool ty.			% boolean type
type integer ty.		% integer type
type arr ty -> ty -> ty.	% arrow type constructor

type tt, ff tm.	  % true and false
type i int -> tm. % integers

type abs (tm -> tm) -> tm.	% abstraction	
type app tm -> tm -> tm. 		% application
% type @ tm -> tm -> tm. 		% application
% infixl @ 120.	   		% @ is infix, and associate to the left.

type eq tm -> tm -> tm.		% equality
type gt tm -> tm -> tm.		% greater than
type ite tm -> tm -> tm -> tm.	% if-then-else

% boolean operators
type and, or tm -> tm -> tm.	
type neg tm -> tm.

% arithmetic operator
type sum, minus, times tm -> tm -> tm. 

% fixed point operator
type fix (tm -> tm) -> tm.

type eval tm -> tm -> o.
type eval_bool tm -> tm -> o.

type typeof tm -> ty -> o.

type tailrec tm -> o.

type prog string -> tm -> o.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% eval
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% eval X _ :- print "eval = " X, fail.

% values
eval tt tt.
eval ff ff.
eval (i I) (i I).
eval (abs M) (abs M).

% applications
eval (app M N) V :- eval M (abs F), eval N T, eval (F T) V. 

% fixed points
eval (fix F) V :- eval (F (fix F)) V.

% if-then-else
eval (ite B M _) V :- eval B tt, eval M V.
eval (ite B _ N) V :- eval B ff, eval N V.

% Special functions:
% for simplicity, no partial applications are allowed for these functions

eval (eq M N) tt :- 
  (eval M (i I), eval N (i I)) ;
  (eval M tt, eval N tt) ;
  (eval M ff, eval N ff).

eval (eq M N) ff :-
  (eval M (i I), eval N (i J), (J < I ; I < J)) ;
  (eval M tt, eval N ff) ;
  (eval M ff, eval N tt).

eval (gt M N) tt :-
  eval M (i I), eval N (i J), I > J.
eval (gt M N) ff :-
  eval M (i I), eval N (i J), (I < J ; I = J).


eval (and M N) V :- eval M V1, eval N V2, eval_bool (and V1 V2) V.
eval (or M N) V  :- eval M V1, eval N V2, eval_bool (or V1 V2) V.
eval (neg M)  V  :- eval M V1, eval_bool (neg V1) V.

eval (sum M N) (i V) :- 
  eval M (i V1), eval N (i V2), V is V1 + V2.
eval (minus M N) (i V) :- 
  eval M (i V1), eval N (i V2), V is V1 - V2.
eval (times M N) (i V) :- 
  eval M (i V1), eval N (i V2), V is V1 * V2.
 

% booleans
eval_bool (and tt tt) tt.
eval_bool (and ff _) ff.
eval_bool (and _  ff) ff.
eval_bool (or ff ff) ff.
eval_bool (or  tt _) tt.
eval_bool (or  _  tt) tt.
eval_bool (neg tt) ff.
eval_bool (neg ff) tt.
           
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% typeof
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

typeof (i _) integer.
typeof tt bool.
typeof ff bool.

% allow equality predicate only on integers and boolean
typeof (eq M N) bool :- typeof M bool, typeof N bool.
typeof (eq M N) bool :- typeof M integer, typeof N integer.
typeof (gt M N) bool :- typeof M integer, typeof N integer.

% arithmetic operators
typeof (sum M N) integer :- typeof M integer, typeof N integer.
typeof (minus M N) integer :- typeof M integer, typeof N integer. 
typeof (times M N) integer :- typeof M integer, typeof N integer.

% boolean operators
typeof (and M N) bool :- typeof M bool, typeof N bool.
typeof (or M N) bool :- typeof M bool, typeof N bool.
typeof (neg N) bool :- typeof N bool.

typeof (ite B M N) A :- typeof B bool, typeof M A, typeof N A.

typeof (app M N) B :- typeof M (arr A B), typeof N A.
typeof (abs M) (arr A B) :- pi x\ typeof x A => typeof (M x) B.
typeof (fix F) A :- pi f\ typeof f A => typeof (F f) A.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tail-recursion recognizer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%tailrec (fix f\ abs n\ abs m\ ite _ _ (app (app f _) _)).
%これは成功するのだが、``_``を変数にすると失敗する。
%ELPIの高階ユニフィケーションが正しくないのだろうか。

tailrec M :- print M, fail.
tailrec (fix M) :- pi f\ trec f (M f).

type trec tm -> tm -> o.
trec F (abs M) :- pi n\ trec F (M n).

% fix (f\ M) の f が、以下の場所に限って出現すること。
trec _ M :- print M, fail.
trec F (ite C N _) :- not (in F C), trec F N.         % then節
trec F (ite C _ N) :- not (in F C), trec F N.         % else節
trec F (app F M) :- not (in F M).                     % apply の第一引数
trec F (app N M) :- trec F N, not (in F M).

% 出現しないことのチェックのための、出現チェック述語
type occr tm -> o.
occr (fix M) :- pi f\ in f (M f).

type in tm -> tm -> o.
in F M :- print "in =" F "in" M, fail.
in F F.
in F (ite N _ _) :- in F N.
in F (ite _ N _) :- in F N.
in F (ite _ _ N) :- in F N.
in F (app N _) :- in F N.
in F (app _ N) :- in F N.
in F (abs M) :- pi x\ in F (M x).
in F (fix M) :- pi f\ in F (M f).
in F (eq N1 N2) :- in F N1; in F N2.
in F (and N1 N2) :- in F N1; in F N2.
in F (or N1 N2) :- in F N1; in F N2.
in F (neq N) :- in F N.
in F (sum N1 N2) :- in F N1; in F N2.
in F (minus N1 N2) :- in F N1; in F N2.
in F (mult N1 N2) :- in F N1; in F N2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Some example programs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Fibonacci
prog "fib" 
(fix fib\ abs n\
  ite (eq n (i 0)) % if
      (i 0)        % then 
      (ite (eq n (i 1))
           (i 1)
           (sum (app fib (minus n (i 1))) (app fib (minus n (i 2))))
      )
).

% Tail-recursive Fibonattii
prog "trec-fib"
(fix fib\ abs n\ abs a\ abs b\
  ite (eq n (i 0))
      a
%     (app (app (app fib (minus (app fib n) (i 1))) b) (sum a b))   % 無理に末尾再帰でない例
      (app (app (app fib (minus n (i 1))) b) (sum a b))             % OK
).

% Factorial
prog "fact" 
(fix fact\ abs n\
  ite (gt n (i 0)) 
      (times n (app fact (minus n (i 1))))
      (i 1)
).

% Tail-recursive factorial
prog "trec-fact"
(fix fact\ abs n\ abs m\
  ite (eq n (i 0)) 
      m
      (app (app fact (minus n (i 1))) (times n m))
).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% eval test
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred go1 o:tm.
go1 X :-
    eval (app {prog "fib"} (i 10)) X.

pred go2 o:tm.
go2 X :-
    eval (app (app (app {prog "trec-fib"} (i 10)) (i 0)) (i 1)) X.

pred go3 o:tm.
go3 X :-
    eval (app {prog "fact"} (i 10)) X.

pred go4 o:tm.
go4 X :-
    eval (app (app {prog "trec-fact"} (i 10)) (i 1)) X.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% typeof  test
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred go11 o:ty.
go11 X :-
    typeof {prog "fib"} X.

pred go12 o:ty.
go12 X :-
    typeof {prog "trec-fib"} X.

pred go13 o:ty.
go13 X :-
    typeof {prog "fact"} X.

pred go14 o:ty.
go14 X :-
    typeof {prog "trec-fact"} X.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% tailrec  test
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred go21.
go21 :-                                  % failure
    tailrec {prog "fib"}.

pred go22.
go22 :-                                 % success
    tailrec {prog "trec-fib"}.

pred go23.
go23 :-                                  % failure
    tailrec {prog "fact"}.

pred go24.
go24 :-                                  % success
    tailrec {prog "trec-fact"}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% in  test
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred go31.
go31 :-                                  % failure
    occr {prog "fib"}.

pred go32.
go32 :-                                 % success
    occr {prog "trec-fib"}.

pred go33.
go33 :-                                  % failure
    occr {prog "fact"}.

pred go34.
go34 :-                                  % success
    occr {prog "trec-fact"}.

% END
