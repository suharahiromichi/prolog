kind tm type.
type a, b, c, d tm.
type o tm.
type (+) tm -> tm -> tm.
type (~) tm -> tm.

pred isvar i:tm.
isvar a.
isvar b.
isvar c.

pred iscnst i:tm.
iscnst o.

pred ax o:int, o:tm, o:tm.
ax 1 (o + a) a.
ax 2 (~ a + a) o.
ax 3 (a + b + c) (a + (b + c)).

pred copy o:tm, o:tm.
copy a a.
copy b b.
copy c c.
copy d d.
copy o o.
copy (A + B) (A1 + B1) :- copy A A1, copy B B1.
copy (~ A) (~ A1) :- copy A A1.

pred subst o:(tm -> tm), o:tm, o:tm.
subst M T S :- pi x\ copy x T => copy (M x) S.

pred mksubtm i:tm, o:tm, o:(tm -> tm).
mksubtm T S C :- subst C S T, not (var S), not (isvar S), not (iscnst S).

pred generalize i:tm, o:(tm -> tm -> tm -> tm).
generalize T F :-
            pi x\ copy a x => pi y\ copy b y => pi z\ copy c z => copy T (F x y z), !.

pred generalize2 i:(tm -> tm), o:(tm -> tm -> tm -> tm -> tm).
generalize2 T F :-
           pi u\ copy u u =>
            pi x\ copy a x => pi y\ copy b y => pi z\ copy c z => copy (T u) (F u x y z), !.

pred test.
test :-
     ax _ L R,
     print "L=" L,
     print "R=" R.

pred test1.
test1 :-
      ax 3 L _,
      mksubtm L S C,
      print "S=" S,
      print "C=" C.

pred test2.
test2 :-
      ax 3 L1 _,
      generalize L1 FL1,
      print "L1=" L1,
      print "FL1=" FL1.


pred unify i:tm, i:tm, o:tm, o:tm, o:tm, o:tm, o:tm, o:tm.
unify L' L X' Y' Z' X Y Z :-
      generalize L' F',
      generalize L F,
      F' X' Y' Z' = F X Y Z,
      print "L'=" (F' X' Y' Z'),
      print "L=" (F X Y Z),
      print "X'=" X',
      print "Y'=" Y',
      print "Z'=" Z',
      print "X=" X,
      print "Y=" Y,
      print "Z=" Z.

pred cpair i:tm, i:tm, i:tm, i:tm, o:tm, o:tm.
cpair L1 R1 L2 R2 Z_R1 Z_CTX_R2 :-
   print "L1=" L1 ", R1=" R1,
   print "L2=" L2 ", R2=" R2,
/*
   L2' = a + b,
   C2' = (x\ x + c),
   L1 = C2' L2',
*/
   mksubtm L1 L2' C2',
   unify L2' L2 X' Y' Z' X Y Z,
   generalize R1 FR1,
   generalize R2 FR2,
   Z_R1 = FR1 X' Y' Z',           % R1

   generalize2 C2' FC2',
   Z_CTX_R2 = FC2' (FR2 X Y Z) X' Y' Z',
   print "σR1=" Z_R1,
   print "σCTX R2=" Z_CTX_R2.


/*
   print "σR1=" Z_R1,
   CTX_R2 = C2' (FR2 X Y Z),      % L1におけるL2'の出現をR2で置き換える。
   print "σR1=" Z_R1,
   print "CTX R2=" CTX_R2,
   print "σR1=" Z_R1,
   generalize CTX_R2 FCR2,              % これで X4 が c になる。ここに無理がある。
   print "CTX R2=" CTX_R2,
   print "σR1=" Z_R1,
   Z_CTX_R2 = FCR2 X' Y' Z',
   print "σR1=" Z_R1,
   print "σCTX R2=" Z_CTX_R2.
*/


pred test3.
test3 :-
   ax 3 L1 R1,          % L1 = (a + b) + c,     R1 = a + (b + c)
   ax 2 L2 R2,          % L2 = (~ a) + a,       R2 = o
   cpair L1 R1 L2 R2 C1 C2,
   print "C1 =" C1 ", C2=" C2.



ax 4 (~ a + (a + b)) b.         % test3 の結果であるべき。

pred test4.
test4 :-
   ax 4 L1 R1,
   ax 1 L2 R2,
   cpair L1 R1 L2 R2 C1 C2,
   print "C1 =" C1 ", C2=" C2.

/* END */
