/**

Constraint Handling Rules (CHR) の例

--------

2023_01_15 @suharahiromichi

*/

/**
# even と odd

X は、同時に even と odd ではあり得ない。


- Elpiプログラミング言語チュートリアル

https://gitlab.com/proofcafe/elpi/-/blob/main/tutorial_elpi_lang_jp.v


- Extensions to λProlog implemented in ELPI

https://github.com/LPCIC/elpi/blob/master/ELPI.md#syntactic-constraints

*/

type z nat.
type s nat -> nat.

pred even i:nat.
even z.
even (s X) :- odd X.
even X :-
     var X, declare_constraint (even X) [X].

pred odd i:nat.
odd (s X) :- even X.
odd X :-
    var X, declare_constraint (odd X) [X].

/**
以下の定義がないと、test はすべて成功してしまう。
*/
constraint even odd {
  % 同じ X に関する 2 つの異なる競合する制約が制約ストアの一部である場合。
  % 制約ストア：変数値に関する部分情報の格納場所
  rule (even X) (odd X) <=>
    (print X "can't be even and odd at the same time",
     fail).
}

pred test00.
pred test01.
pred test02.
test00 :-
      even (X), odd (X).        /* Failure */
test01 :-
      even (s X), odd (s X).    /* Failure */
test02 :-
      even (X), odd (s X).      /* Success */


/**
# 順序集合を表す二項関係の制約

## LEQ ``≦`` の制約

https://ja.wikipedia.org/wiki/Constraint_Handling_Rules
*/

pred leq i:int, i:int.
leq (uvar as A) (uvar as B) :- !,
    declare_constraint (leq A B) [A,B].
leq A           (uvar as B) :- !,
    declare_constraint (leq A B) [B].
leq (uvar as A) B         :- !,
    declare_constraint (leq A B) [A].

/**
制約は重複できないため、Wikipediaにある test11 の成立する(LEQの例)だけなら、以下でよい。
*/
/*
constraint leq {
  rule \ (leq X X).                       % refl 反射律
  rule (leq X Y) \ (leq Y X) <=> (Y = X). % atisym 半対称律
  rule (leq X Y) (leq Y Z) <=> (leq X Z). % trans 推移性
  rule (leq X Y) \ (leq X Y) <=> true.    % idempotence 等冪性
}
*/

pred test11.
test11 :-
      leq X Y, leq Y Z, leq Z X.        /* Success */

/**
## LTN ``<`` を追加する。

elpi/tests/sources/chrLEQ.elpi
*/

pred ltn i:int, i:int.
ltn (uvar as A) (uvar as B) :- !,               % uvar as A は、(var A) の意味
    declare_constraint (ltn A B) [A,B].
ltn A           (uvar as B) :- !,
    declare_constraint (ltn A B) [B].
ltn (uvar as A) B         :- !,
    declare_constraint (ltn A B) [A].

constraint leq ltn {
  rule (leq X Y) (ltn Y X) <=> false.           % incompat (FIRST!!)
  rule (ltn X Y) (ltn Y X) <=> false.
  rule (ltn X X) <=> false.
  rule \ (leq X X).                             % refl
  rule (leq X Y) \ (leq Y X) <=> (Y = X).       % atisym
  rule (leq X Y) (leq Y Z) <=> (leq X Z).       % trans
  rule (leq X Y) (ltn Y Z) <=> (ltn X Z).
  rule (ltn X Y) (leq Y Z) <=> (ltn X Z).
  rule (ltn X Y) (ltn Y Z) <=> (ltn X Z).
  rule (leq X Y) \ (leq X Y).                   % idempotence
  rule (ltn X Y) \ (ltn X Y).
}

pred test12.
test12 :-
     leq A B, leq B C, not (ltn C A), ltn A B, not(A = C).              /* Success */


/**
# 最大公約数

## 最大公約数（その1）

https://github.com/LPCIC/elpi/blob/master/tests/sources/chrGCD.elpi

99と66の最大公約数が11であるので、
``gcd' 99 X, gcd' 66 X, X = p11`` が成り立つ。
*/

kind prime type.
type p11 prime.
type p7 prime.
pred gcd' i:int, i:prime.

gcd' A (uvar as B) :- !,
    declare_constraint (gcd' A B) [B].
%% ここは素数でないといけない。
gcd' 11 p11 :- print "prime 11 solved".
gcd' 7 p7 :- print "prime 7 solved".

constraint gcd' {
  rule (gcd' A _) \ (gcd' B _) | (A = B).     % rule1
  rule (gcd' A _) \ (gcd' B X) | (A < B) <=> (C is (B - A), gcd' C X). % rule2
}

pred test21.
pred test22.
pred test20.
test21 :-                               /* 99と77のGCDは11である。 */
       gcd' 99 X, gcd' 77 X, X = p11.
test22 :-                               /* 14と77のGCDは7である。 */
       gcd' 14 Y, gcd' 77 Y, Y = p7.
test20 :-
       gcd' 99 X, gcd' 66 X, gcd' 14 Y, gcd' 22 X, gcd' 77 Y,
       % we then force a resumption to check only GCDs are there
       X = p11, Y = p7.

/**

```
gcd A Y, gcd B X, A = B
------------------------ rule1
true
```

```
gcd A Y, gcd B X, A < B
------------------------ rule2
gcd A Y, gcd (B - A) X
```

```
gcd 14 Y, gcd 77 Y
------------------- rule2
gcd 14 Y, gcd 63 Y
------------------- rule2
gcd 14 Y, gcd 7  Y
------------------- gcd 7 Y
gcd 14 Y, gcd 7 p7
------------------- rule2
gcd 7  Y, gcd 7 p7
------------------- gcd 7 Y
gcd 7 p7, gcd 7 p7
------------------- rule1
true
```

*/

/**
## 最大公約数（その2、ユーグリッドの互除法)

## 素数

## フィボナッチ数

https://ja.wikipedia.org/wiki/Constraint_Handling_Rules

*/


/**
# 有限ドメイン (N.G.)

https://www.swi-prolog.org/pldoc/man?section=chr-examples
*/

pred intersection o:list X, o:list X, o:list X.
intersection [] L L.
intersection [X|L1] L2 L3 :-
             std.mem L2 X, !,
             intersection L1 L2 L3.
intersection [X|L1] L2 [X|L3] :-
             intersection L1 L2 L3.

pred dom i:X, o:list X.
dom X L :-
    print "don= " X L,
    var X, !,
    declare_constraint (dom X L) [X].

constraint dom {
  rule (dom X [])            <=> fail.
  rule (dom X [Y])           <=> (X = Y).
  rule (dom X L) | (nonvar X, std.mem L X) <=> true.
  rule (dom X L1) (dom X L2) | (intersection L1 L2 L3) <=> (dom X L3).
}

pred test4.
test4 :-                                /* Success */
      dom A [1,2,3], dom A [3,4,5],     /* A = 3 */
      print "A = " A.


/**
# Example of high order rules (作成中)

https://github.com/LPCIC/elpi/blob/master/ELPI.md#example-of-higher-order-rules
*/

mode (term i o).
term (app HD ARG) TGT :- term HD (arrow SRC TGT), term ARG SRC.
term (lam F) (arrow SRC TGT) :- pi x\ term x SRC => term (F x) TGT.
term (uvar as X) T :- declare_constraint (term X T) [X].

constraint term {
  rule (GX ?- term (uvar K LX) TX)
     \ (GY ?- term (uvar K LY) TY)
     | (compatible GX LX GY LY CTXEQS)
   <=> [TX = TY | CTXEQS].
}

compatible _ [] _ [] [] :- !.
compatible GX [X|XS] GY [Y|YS] [TX = TY | K] :-
 (GX => term X TX),
 (GY => term Y TY),
 !,
 compatible GX XS GY YS K.
compatible _ _ _ _ [].

main10 :-
  (term (lam x\ lam y\ app (app (F x y) x) y) T1),
  (term (lam y\ lam x\ app (app (F x y) y) x) T2).


/* END */
